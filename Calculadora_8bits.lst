CCS PCH C Compiler, Version 5.012, 41559               18-mar-17 22:25

               Filename:   C:\Users\lazaax\Documents\GitHub\Practica\Calculadora_8bits.lst

               ROM used:   210 bytes (0%)
                           Largest free fragment is 65326
               RAM used:   5 (0%) at main() level
                           11 (0%) worst case
               Stack used: 2 locations
               Stack size: 31

*
00000:  GOTO   0054
.................... #include <18F4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT 
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG 
.................... #use delay(clock=32000000) 
00004:  CLRF   FEA
00006:  MOVLW  0B
00008:  MOVWF  FE9
0000A:  MOVF   FEF,W
0000C:  BZ    0028
0000E:  MOVLW  0A
00010:  MOVWF  01
00012:  CLRF   00
00014:  DECFSZ 00,F
00016:  BRA    0014
00018:  DECFSZ 01,F
0001A:  BRA    0012
0001C:  MOVLW  5F
0001E:  MOVWF  00
00020:  DECFSZ 00,F
00022:  BRA    0020
00024:  DECFSZ FEF,F
00026:  BRA    000E
00028:  GOTO   0044 (RETURN)
.................... #use standard_io(b) 
.................... #define retardo 500 
....................  
.................... void error(); 
....................  
.................... void main (void){ 
*
00054:  CLRF   FF8
00056:  BCF    FD0.7
00058:  MOVLW  70
0005A:  MOVWF  FD3
0005C:  MOVLW  40
0005E:  MOVWF  F9B
00060:  MOVF   FD3,W
00062:  MOVF   FC1,W
00064:  ANDLW  C0
00066:  IORLW  0F
00068:  MOVWF  FC1
0006A:  MOVLW  07
0006C:  MOVWF  FB4
....................    set_tris_c(0b11111111); 
0006E:  MOVLW  FF
00070:  MOVWF  F94
....................    set_tris_d(0b11111111); 
00072:  MOVWF  F95
....................    int16 resultado=0; 
....................    int8 operando1=0,operando2=0; 
00074:  CLRF   06
00076:  CLRF   05
00078:  CLRF   07
0007A:  CLRF   08
....................    setup_oscillator(OSC_32MHZ); 
0007C:  MOVLW  70
0007E:  MOVWF  FD3
00080:  MOVLW  40
00082:  MOVWF  F9B
00084:  MOVF   FD3,W
....................     
....................    while(True){ 
....................    operando1=input_c(); 
00086:  SETF   F94
00088:  MOVFF  F82,07
....................    operando2=input_d(); 
0008C:  SETF   F95
0008E:  MOVFF  F83,08
....................    if(input(PIN_B3) == 1){ 
00092:  BSF    F93.3
00094:  BTFSS  F81.3
00096:  BRA    00A0
....................    resultado = operando1 + operando2; 
00098:  MOVF   08,W
0009A:  ADDWF  07,W
0009C:  MOVWF  05
0009E:  CLRF   06
....................        
....................    } 
....................    if(input(PIN_B4) == 1) 
000A0:  BSF    F93.4
000A2:  BTFSS  F81.4
000A4:  BRA    00AE
....................    { 
....................    resultado = operando1 - operando2; 
000A6:  MOVF   08,W
000A8:  SUBWF  07,W
000AA:  MOVWF  05
000AC:  CLRF   06
....................    } 
....................    if(input(PIN_B5) == 1) 
000AE:  BSF    F93.5
000B0:  BTFSS  F81.5
000B2:  BRA    00BE
....................    { 
....................    resultado = operando1 * operando2; 
000B4:  MOVF   07,W
000B6:  MULWF  08
000B8:  MOVF   FF3,W
000BA:  CLRF   06
000BC:  MOVWF  05
....................    } 
....................    if(input(PIN_B6) == 1) 
000BE:  BSF    F93.6
000C0:  BTFSS  F81.6
000C2:  BRA    00CE
....................    { 
....................    if(input_d()==0) 
000C4:  SETF   F95
000C6:  MOVF   F83,F
000C8:  BNZ   00CC
....................    error(); 
000CA:  BRA    002C
....................    break; 
000CC:  BRA    00D0
....................    } 
000CE:  BRA    0086
....................    } 
.................... }    
.................... void error() 
000D0:  SLEEP 
.................... { 
....................    int i; 
....................    for(i=0;i<5;i++) 
*
0002C:  CLRF   09
0002E:  MOVF   09,W
00030:  SUBLW  04
00032:  BNC   0050
....................    { 
....................    output_b(0b00000001); 
00034:  CLRF   F93
00036:  MOVLW  01
00038:  MOVWF  F8A
....................    delay_ms(retardo); 
0003A:  MOVLW  02
0003C:  MOVWF  0A
0003E:  MOVLW  FA
00040:  MOVWF  0B
00042:  BRA    0004
00044:  DECFSZ 0A,F
00046:  BRA    003E
....................    output_b(0b00000000); 
00048:  CLRF   F93
0004A:  CLRF   F8A
0004C:  INCF   09,F
0004E:  BRA    002E
....................    } 
00050:  GOTO   00CC (RETURN)
.................... } 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
